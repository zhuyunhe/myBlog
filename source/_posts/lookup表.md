---
title: lookup表
date: 2016-05-31 18:41:01
tags:
- 学习
- JavaScript
categories: 学习笔记
---
今天看书时看到一个新词“lookup表”，翻译过来应该“查找表”。  
书中的例子是这样的：  
'圈复杂度高的代码通常是由很多if/then/else语句造成的。最简单的重构修复，是将方法分解成更小的方法，或使用一个lookup表。如下是我们所说的场景示例:  
	
	function doSomething(a){
		if(a === 'x'){
			doX();
		} else if(a === 'y'){
			doY();
		} else{
			doZ();
		}
	}
使用lookup表重构的示例如下：  

	function doSomething(a){
		var lookup = {x: doX, y: doY}, def = doZ;
		lookup[a] ? lookup[a]() : def();
	}
注意，通过使用lookup表重构条件语句后，我们并没有减少必须的单元测试数量。...'  

---
然后维基百科是这么告诉我的：  
'在计算机科学中，查找表是用简单的查询操作替换运行时计算的数组或者关联数组这样的数据结构。由于从内存中提取数值经常要比复杂的计算速度快很多。所以这样得到的速度提升是很显著的。  
一个经典的例子就是三角函数表。每次计算所需的正弦值在一些应用中可能会慢得无法忍受，为了避免这种情况，应用程序可以在刚开始的一段时间计算一定数量的角度的正弦值，譬如计算每个整数角度的正弦值，在后面的程序需要正弦值的时候，使用查找表从内存中提取临近角度的正弦值而不是使用数学公式计算。'  
看到这里大概就明白lookup表是什么了，其实以前上学的时候也学过，和插值计算什么很类似。不过维基百科上讲到了一个查找表应用的例子，觉得还挺有意思，顺手玩一下。  
例子：  
###计算1的位数
例如，数字37的二进制式是100101，所以它包含三个设置成1的位。一个计算32位整数中1的位数的简单程序如下：  
	
	function count_ones_circul(x){
		var result = 0;
		while(x > 0){
			result += x&1;
			x = x >> 1;
		}
		return result;
	}
不幸的是，这个简单的算法在现代的架构上将需要数以百计的时钟周期才能完成，这是因为它造成了很多分支和循环，而分支的速度是很慢的。这可以使用循环展开和其它一些聪明的技巧进行改进，但最简单快捷的解决方案是查找表：简单地构建一个每个字节可能的值包含的1的个数的条目标，由于一个字节8位可以表示256个可能值，所以这个表一共有256个条目。然后使用这个表查找整数中每个字节包含的1的个数，并且将结果相加。没有分支、只有简单的加法算术运算，与上面的算法相比就可以大幅度提升速度。  
在这里我只是构建了一个半个字节（4位）可能的值包含的1的个数的条目（一个字节256个太多了呜），用来找出一个16位的整数中1的位数，原理其实是一样的。 
 
	var lookup = [
				 	0,1,1,2,1,2,2,3,
					1,2,2,3,2,3,3,4
				 ];
	function count_ones(){
		return lookup[x&15] + lookup[(x>>4)&15] + lookup[(x>>8)&15] + lookup[(x>>12)&15];
	}
运行一下，结果应该是对的。  
![lookup](/image/lookup/1.png)



